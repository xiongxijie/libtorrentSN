TotemWindow.h

class MyHdyApplicationWindow : public Gtk::Window 
{
public:

    MyHdyApplicationWindow(BaseObjectType* cobject, 
                           Glib::RefPtr<Gtk::Builder> const& builder,
                           Gtk::Window& parent);

    ~MyHdyApplicationWindow() override;
.....
  }


TotemWindow.cc
#include "TotemWrapper.h"
.......
MyHdyApplicationWindow::Impl::Impl(
  MyHdyApplicationWindow& window,
  Glib::RefPtr<Gtk::Builder> const& builder)
  : parent_(window),
action_group_(Gio::SimpleActionGroup::create()),
flap_(gtr_get_widget_derived<MyHdyFlap>(builder, "flap")),
player_header_(gtr_get_widget_derived<TotemPlayerHeader>(builder, "player_header")),
  prefs_(TotemPrefsDialog::create())

{
  //create the Wrapper
  wrapper_ = totem_wrapper_from_gtkmm_instance(&parent_);


}
......

TotemWrapper.h

#pragma once


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h> //for those Gtk types

#ifdef __cplusplus
class MyHdyApplicationWindow;
#endif

// Define the GObject type for TotemWrapper   
#define TOTEM_TYPE_WRAPPER (totem_wrapper_get_type())
G_DECLARE_FINAL_TYPE(TotemWrapper, totem_wrapper, TOTEM, WRAPPER, GObject)


#ifdef __cplusplus
extern "C" {

// Function to create a new TotemWrapper instance used by totem_wrapper_from_gtkmm_instance()
TotemWrapper *totem_wrapper_new (void);

// Function to associate an existing gtkmm instance with the wrapper
TotemWrapper *totem_wrapper_from_gtkmm_instance (MyHdyApplicationWindow *gtkmm_instance);

void totem_wrapper_cleanup (TotemWrapper *wrapper);

}
#endif


TotemWrapper.cc
#include "TotemWindow.h" // for MyhdyApplication class type
#include "TotemWrapper.h"// for TotemWrapper type define and function signatures


struct _TotemWrapper {
  GObject parent_instance;               // GObject parent class
  MyHdyApplicationWindow *gtkmm_instance; // The wrapped gtkmm instance
};

// Define the GObject type for TotemWrapper
G_DEFINE_TYPE(TotemWrapper, totem_wrapper, G_TYPE_OBJECT)

.....

// Function to create a new TotemWrapper instance
TotemWrapper *totem_wrapper_new (void) 
{
    // Create a new TotemWrapper instance using GObject
    TotemWrapper *obj = TOTEM_WRAPPER (g_object_new(TOTEM_TYPE_WRAPPER, NULL));

    // Ensure the object was created successfully
    if (!obj) {
        return NULL;
    }

    // Initialize the wrapped gtkmm instance to NULL
    obj->gtkmm_instance = NULL;

    return obj;
}


// Function to cast an existing gtkmm instance to a TotemWrapper object
TotemWrapper *totem_wrapper_from_gtkmm_instance (MyHdyApplicationWindow *gtkmm_instance) 
{
    // Ensure we have a valid gtkmm instance
    if (!gtkmm_instance) {
        return NULL;
    }

    // Create a new TotemWrapper wrapper instance
    TotemWrapper *obj = totem_wrapper_new();
    
    if (!obj) {
        return NULL;  // Handle allocation failure gracefully
    }

    // Set the existing gtkmm instance into the wrapper
    obj->gtkmm_instance = gtkmm_instance;

    // printf ("called totem_wrapper_from_gtkmm_instance \n");

    return obj;
}

void totem_wrapper_cleanup (TotemWrapper *wrapper)
{

    g_clear_object(&wrapper);
}

TotemWrapper is a c++ wrapper for MyHdyApplicationWindow class, it accept MyHdyApplicationWindow instance address,
but there might be circular dependency between TotemWrapper and MyhdyApplicationWindow,
the key is in totem_wrapper_from_gtkmm_instance expects a type MyhdyApplicationWindow, so it has to include "TotemWindow.h", which 
cause a circular dependecy, how to solve the problem ?
